rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // ========================================
    // HELPER FUNCTIONS
    // ========================================
    
    // Basic authentication check
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if user owns the resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Get current user's data
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }
    
    // Check if user exists
    function userExists(userId) {
      return exists(/databases/$(database)/documents/users/$(userId));
    }
    
    // User type checks
    function isFreelancer() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             getUserData().userType in ['freelancer', 'both'];
    }
    
    function isClient() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             getUserData().userType in ['client', 'both'];
    }
    
    function isBoth() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             getUserData().userType == 'both';
    }
    
    // Profile completion checks
    function hasCompleteProfile() {
      return isAuthenticated() && 
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             getUserData().profileCompleted == true;
    }
    
    function hasBasicProfile() {
      return isAuthenticated() && 
             getUserData().displayName != null &&
             getUserData().bio != null &&
             getUserData().location != null;
    }
    
    function hasFreelancerProfile() {
      return hasBasicProfile() &&
             getUserData().skills.size() > 0 &&
             getUserData().hourlyRate > 0;
    }
    
    function hasClientProfile() {
      return hasBasicProfile() &&
             (getUserData().companyName != null || getUserData().userType == 'both');
    }
    
    // Verification and trust checks
    function isVerified() {
      return isAuthenticated() && 
             getUserData().isVerified == true;
    }
    
    function isNotBlocked() {
      return isAuthenticated() && 
             (getUserData().isBlocked == false || 
              getUserData().isBlocked == null);
    }
    
    // Job validation
    function isValidJob(data) {
      return data.title != null && data.title.size() >= 10 &&
             data.description != null && data.description.size() >= 50 &&
             data.category != null &&
             data.skills.size() > 0 &&
             data.budgetMin > 0 &&
             data.budgetMax >= data.budgetMin &&
             data.clientId == request.auth.uid;
    }
    
    // Proposal validation
    function isValidProposal(data) {
      return data.coverLetter != null && data.coverLetter.size() >= 50 &&
             data.proposedRate > 0 &&
             data.freelancerId == request.auth.uid &&
             exists(/databases/$(database)/documents/jobs/$(data.jobId));
    }
    
    // Check if user already proposed to a job
    function hasNotProposed(jobId) {
      return !exists(/databases/$(database)/documents/proposals/$(jobId + '_' + request.auth.uid));
    }
    
    // ========================================
    // USERS COLLECTION
    // ========================================
    match /users/{userId} {
      // Anyone can read public profile info
      allow read: if true;
      
      // Only the user can create their own profile
      allow create: if isOwner(userId) &&
                      request.resource.data.email == request.auth.token.email &&
                      request.resource.data.userType in ['freelancer', 'client', 'both'];
      
      // Users can update their own profile with restrictions
      allow update: if isOwner(userId) && isNotBlocked() && (
        // Prevent changing critical fields
        (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['uid', 'email', 'createdAt'])) &&
        // Freelancers cannot change to client-only
        (resource.data.userType != 'freelancer' || request.resource.data.userType != 'client') &&
        // Clients cannot change to freelancer-only
        (resource.data.userType != 'client' || request.resource.data.userType != 'freelancer')
      );
      
      // Allow other users to update lastMessageTime for chat
      allow update: if isAuthenticated() && 
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastMessageTime']);
      
      // Users cannot be deleted
      allow delete: if false;
    }
    
    // ========================================
    // JOBS COLLECTION
    // ========================================
    match /jobs/{jobId} {
      // Anyone authenticated can read jobs
      allow read: if isAuthenticated();
      
      // Only clients with complete profiles can create jobs
      allow create: if isClient() && 
                      hasCompleteProfile() &&
                      hasClientProfile() &&
                      isNotBlocked() &&
                      isValidJob(request.resource.data) &&
                      request.resource.data.status == 'open';
      
      // Only job owner can update
      allow update: if isAuthenticated() && 
                      resource.data.clientId == request.auth.uid && (
        // Prevent changing ownership
        request.resource.data.clientId == resource.data.clientId &&
        // Validate status transitions
        (
          (resource.data.status == 'open' && request.resource.data.status in ['open', 'in-progress', 'cancelled']) ||
          (resource.data.status == 'in-progress' && request.resource.data.status in ['in-progress', 'completed', 'disputed']) ||
          (resource.data.status == 'completed' && request.resource.data.status == 'completed') ||
          (resource.data.status == 'cancelled' && request.resource.data.status == 'cancelled')
        )
      );
      
      // Only job owner can delete (soft delete preferred)
      allow delete: if isAuthenticated() && 
                      resource.data.clientId == request.auth.uid &&
                      resource.data.status in ['open', 'cancelled'];
    }
    
    // ========================================
    // PROPOSALS COLLECTION
    // ========================================
    match /proposals/{proposalId} {
      // Freelancer and client can read
      allow read: if isAuthenticated() && 
                    (resource.data.freelancerId == request.auth.uid || 
                     resource.data.clientId == request.auth.uid);
      
      // Only freelancers with complete profiles can create proposals
      allow create: if isFreelancer() && 
                      hasCompleteProfile() &&
                      hasFreelancerProfile() &&
                      isNotBlocked() &&
                      isValidProposal(request.resource.data) &&
                      hasNotProposed(request.resource.data.jobId) &&
                      request.resource.data.status == 'pending';
      
      // Freelancer can update their proposal, client can accept/reject
      allow update: if isAuthenticated() && isNotBlocked() && (
        // Freelancer can withdraw
        (resource.data.freelancerId == request.auth.uid && 
         resource.data.status == 'pending' &&
         request.resource.data.status == 'withdrawn') ||
        // Client can accept/reject
        (resource.data.clientId == request.auth.uid &&
         resource.data.status == 'pending' &&
         request.resource.data.status in ['accepted', 'rejected'])
      );
      
      // Only freelancer can delete their pending proposal
      allow delete: if isAuthenticated() && 
                      resource.data.freelancerId == request.auth.uid &&
                      resource.data.status == 'pending';
    }
    
    // ========================================
    // CONTRACTS COLLECTION
    // ========================================
    match /contracts/{contractId} {
      // Parties can read their contracts
      allow read: if isAuthenticated() && 
                    (resource.data.freelancerId == request.auth.uid || 
                     resource.data.clientId == request.auth.uid);
      
      // Only clients can create contracts
      allow create: if isClient() && 
                      hasCompleteProfile() &&
                      isNotBlocked() &&
                      request.auth.uid == request.resource.data.clientId &&
                      userExists(request.resource.data.freelancerId) &&
                      request.resource.data.status == 'active';
      
      // Both parties can update certain fields
      allow update: if isAuthenticated() && isNotBlocked() && (
        // Client can update contract details
        (resource.data.clientId == request.auth.uid &&
         request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['status', 'endDate', 'totalAmount', 'updatedAt'])) ||
        // Freelancer can update their acceptance
        (resource.data.freelancerId == request.auth.uid &&
         request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['freelancerAccepted', 'updatedAt']))
      );
      
      // Contracts cannot be deleted
      allow delete: if false;
    }
    
    // ========================================
    // CONVERSATIONS COLLECTION
    // ========================================
    match /conversations/{conversationId} {
      // Participants can read
      allow read: if isAuthenticated() && 
                    request.auth.uid in resource.data.participants;
      
      // Authenticated users can create conversations
      allow create: if isAuthenticated() && 
                      hasCompleteProfile() &&
                      isNotBlocked() &&
                      request.auth.uid in request.resource.data.participants &&
                      request.resource.data.participants.size() == 2;
      
      // Participants can update last message info
      allow update: if isAuthenticated() && 
                      request.auth.uid in resource.data.participants &&
                      request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['lastMessage', 'lastMessageTime', 'unreadCount']);
      
      // Conversations cannot be deleted
      allow delete: if false;
      
      // Messages subcollection
      match /messages/{messageId} {
        // Participants can read messages
        allow read: if isAuthenticated() && 
                      request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
        
        // Participants can send messages
        allow create: if isAuthenticated() && 
                        isNotBlocked() &&
                        request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants &&
                        request.auth.uid == request.resource.data.senderId;
        
        // Only recipient can mark as read
        allow update: if isAuthenticated() && 
                        request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants &&
                        request.auth.uid != resource.data.senderId &&
                        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt']);
        
        // Messages cannot be deleted
        allow delete: if false;
      }
    }
    
    // ========================================
    // NOTIFICATIONS COLLECTION
    // ========================================
    match /notifications/{notificationId} {
      // Users can read their own notifications
      allow read: if isAuthenticated() && 
                    resource.data.userId == request.auth.uid;
      
      // System can create notifications (in practice, use Cloud Functions)
      allow create: if isAuthenticated() && 
                      request.resource.data.userId != null &&
                      userExists(request.resource.data.userId);
      
      // Users can mark their notifications as read
      allow update: if isAuthenticated() && 
                      resource.data.userId == request.auth.uid &&
                      request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['read', 'readAt']);
      
      // Users can delete their notifications
      allow delete: if isAuthenticated() && 
                      resource.data.userId == request.auth.uid;
    }
    
    // ========================================
    // REVIEWS COLLECTION
    // ========================================
    match /reviews/{reviewId} {
      // Public can read reviews
      allow read: if true;
      
      // Only users who completed a contract can review
      allow create: if isAuthenticated() && 
                      hasCompleteProfile() &&
                      isNotBlocked() &&
                      request.auth.uid == request.resource.data.reviewerId &&
                      exists(/databases/$(database)/documents/contracts/$(request.resource.data.contractId)) &&
                      get(/databases/$(database)/documents/contracts/$(request.resource.data.contractId)).data.status == 'completed' &&
                      (
                        get(/databases/$(database)/documents/contracts/$(request.resource.data.contractId)).data.clientId == request.auth.uid ||
                        get(/databases/$(database)/documents/contracts/$(request.resource.data.contractId)).data.freelancerId == request.auth.uid
                      );
      
      // Reviews cannot be edited or deleted
      allow update: if false;
      allow delete: if false;
    }
    
    // ========================================
    // TRANSACTIONS COLLECTION
    // ========================================
    match /transactions/{transactionId} {
      // Parties can read their transactions
      allow read: if isAuthenticated() && 
                    (resource.data.freelancerId == request.auth.uid || 
                     resource.data.clientId == request.auth.uid);
      
      // Only Cloud Functions can create/update transactions
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
    
    // ========================================
    // CATEGORIES COLLECTION
    // ========================================
    match /categories/{categoryId} {
      // Public read access
      allow read: if true;
      // Only admin through console
      allow write: if false;
    }
    
    // ========================================
    // SKILLS COLLECTION
    // ========================================
    match /skills/{skillId} {
      // Public read access
      allow read: if true;
      // Only admin through console
      allow write: if false;
    }
    
    // ========================================
    // SAVED ITEMS (Subcollections)
    // ========================================
    match /users/{userId}/savedJobs/{savedJobId} {
      allow read: if isOwner(userId);
      allow write: if isOwner(userId) && 
                     exists(/databases/$(database)/documents/jobs/$(savedJobId));
      allow delete: if isOwner(userId);
    }
    
    match /users/{userId}/savedFreelancers/{savedFreelancerId} {
      allow read: if isOwner(userId);
      allow write: if isOwner(userId) && isClient() &&
                     exists(/databases/$(database)/documents/users/$(savedFreelancerId));
      allow delete: if isOwner(userId);
    }
    
    // ========================================
    // ANALYTICS/STATS (Read-only for users)
    // ========================================
    match /analytics/{docId} {
      allow read: if isAuthenticated() && 
                    (docId == request.auth.uid || 
                     docId == 'platform');
      allow write: if false; // Only Cloud Functions
    }
    
    // ========================================
    // REPORTS/FLAGS
    // ========================================
    match /reports/{reportId} {
      // Users can create reports
      allow create: if isAuthenticated() && 
                      hasCompleteProfile() &&
                      request.auth.uid == request.resource.data.reporterId &&
                      request.resource.data.status == 'pending';
      
      // Only admins can read/update (implement admin check)
      allow read: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}